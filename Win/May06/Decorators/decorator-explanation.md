Use a gift-wrapping analogy to describe how a decorator adds functionality to a function without altering the core function itself.

Absolutely! Let's illustrate how decorators work using a gift-wrapping analogy:

The Core Function (The Gift): Imagine a function as a gift. The job of the function is to provide its core present, like a book, a toy, or a gadget.

The Decorator (The Gift Wrapping): A decorator acts like fancy gift wrapping. It takes the gift (the function) and puts a beautiful layer of decoration around it. This could be fancy wrapping paper, a bow, or even a decorative box.

The Modified Function (The Wrapped Gift):  After the decorator has done its work, the gift is now enhanced. It looks nicer, more festive, and perhaps has some extra features (like that fancy bow on top). The core gift, however, remains unchanged.

How It Translates to Code

The present function: This represents your core function, which offers its basic functionality.
The gift_wrap decorator: This is akin to adding gift wrappingâ€”it takes your function and enhances it.
The wrapper function: Inside the decorator, this function handles wrapping the original function with the added features.
The Beauty of Decorators

Just like you can change the gift wrapping without altering the gift itself, decorators allow you to add extra features to your function without modifying the original code of that function. This keeps your core functions clean, and lets you easily add or remove these enhancements with decorators as needed. 
